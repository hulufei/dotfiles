snippet vt "Variant type"
type ${1:action} =
	| ${2:Tag}
endsnippet

snippet us "Unicode string"
{js|${1:unicode}|js}
endsnippet

snippet urs "Unicode ReasonReact.string"
({js|${1:unicode}|js} |> ReasonReact.string)
endsnippet

snippet rs "ReasonReact.string"
($0 |> ReasonReact.string)
endsnippet

snippet sc "statelessComponent" b
let component = "${1:ComponentName}" |> ReasonReact.statelessComponent;

let make = (_children) => {
	...component,
	render: _self =>
	<div>
		${0:("Hello" |> ReasonReact.string)}
	</div>,
};
endsnippet

snippet rc "reducerComponent" b
type state = ${1:unit}
type action =
	| ${2:Action}

let component = "${3:ComponentName}" |> ReasonReact.reducerComponent;

let make = (_children) => {
	...component,
	initialState: () => ${4:()},
	reducer: (action, _state) =>
		switch (action) {
		| $2 => ReasonReact.${5:NoUpdate}
		},
	render: _self =>
		<div>
			${0:("Hello" |> ReasonReact.string)}
		</div>,
}
endsnippet

snippet rcp "reducerComponent with retainedProps" b
type state = ${1:unit}
type action =
	| ${2:Action}

type retainedProps = {
	${7:propName}: ${8:propValueType}
}
let component = "${3:ComponentName}" |> ReasonReact.reducerComponentWithRetainedProps;

let make = (~${10:propName}, _children) => {
	...component,
	initialState: () => ${4:()},
	retainedProps: {
		$7: $10,
	},
	didUpdate: ({oldSelf, newSelf}) =>
		if (oldSelf.retainedProps.$7 !== newSelf.retainedProps.$7) {
			${9:action} |> newSelf.send;
		},
	reducer: (action, _state) =>
		switch (action) {
		| $2 => ReasonReact.${5:NoUpdate}
		},
	render: _self =>
		<div>
			${0:("Hello" |> ReasonReact.string)}
		</div>,
}
endsnippet

snippet match "pattern match"
switch(${1:var}) {
| ${2:pattern} => ${3:expression}
}
endsnippet

snippet matcha "pattern match an array"
switch(${1:var}) {
| [||] => ${2:empty match}
| [|${3:otherwise}|] => ${4:expression}
}
endsnippet

snippet matchl "pattern match a list"
switch(${1:var}) {
| [] => ${2:empty match}
| [x, ...${3:others}] => ${4:expression}
}
endsnippet

snippet matcho "pattern match on an option type"
switch(${1:var}) {
| None => ${2:expression}
| Some(${3:data}) => ${4:expression}
}
endsnippet

snippet matchr "pattern match on an remote result type"
switch (${1:var}) {
| ${5:RequestName}.NotAsked
| $5.Loading => ${2:"Loading..." |> ReasonReact.string}
| $5.Error({msg}) => ${3: msg |> ReasonReact.string}
| $5.Ok(${4:data}) =>
	$0
}
endsnippet

snippet fc "function"
let ${1:name} = (${2:params}) => {
	$0
}
endsnippet

snippet afc "anonymous function"
(${1:params}) => {
	$0
}
endsnippet

snippet let "let binding"
let ${1:x} = ${2:v};
endsnippet

snippet if "if condition"
if (${1:condition}) {
	${2: /* A */}
} else {
	${3: /* B */}
}
endsnippet

snippet ift "if ternary sugar"
${1:cond} ? ${2: expression} :
	${3: expression}
endsnippet

snippet mod "define module"
module ${1:Name} = {
	${2:/* Module contents */}
};
endsnippet

snippet sig "module type signature"
module type ${1:ModTypeName} {
	${2: /* body of interface */}
}
endsnippet

snippet ft "functor"
module type ${1:ParamI} {
	${2: /* body of params interface */}
}

module ${3:FunctorName} = (${4:ParamModule1}: $1) => {
	${5:/* body of functor */}
}
endsnippet

snippet ra "ReasonReact.array"
[|${1:arrayElems}|] |> ReasonReact.array
endsnippet

snippet lra "list to ReasonReact.array"
${1:arrayElems} |> Array.of_list |> ReasonReact.array
endsnippet

snippet mra "map list to ReasonReact.array"
${1:items} |> List.map((${2:item}) => {
	${0:/* item element */}
}) |> Array.of_list |> ReasonReact.array
endsnippet

snippet jdf "json field"
${1:name}: json |> field("${2:$1}", ${3:decoder}),
endsnippet

snippet jd "Json.Decode"
let ${1:dataDecode} = json =>
	Json.Decode.{
		${2:name}: json |> field("${3:$2}", ${4:decoder}),
	};
endsnippet

snippet tjd "type with json decode"
type ${1:name} = {
	${2:k}: ${3:int},
	${4:k}: ${5:int},
	${6:k}: ${7:int},
	${8:k}: ${9:int},
};
let ${10:$1}Decode = json =>
	Json.Decode.{
		$2: json |> field("$2", $3),
		$4: json |> field("$4", $5),
		$6: json |> field("$6", $7),
		$8: json |> field("$8", $9),
	}
endsnippet

snippet bc "Bind component"
/* Antd styles already included in less */
/* [%bs.raw {|require("antd/lib/${1:name}/style")|}]; */

[@bs.deriving abstract]
type jsProps = {
	[@bs.optional]
	${2:prop}: ${3:value},
	[@bs.optional]
	${4:prop}: ${5:value},
	[@bs.optional]
	${6:prop}: ${7:value},
	[@bs.optional]
	${8:prop}: ${9:value},
	[@bs.optional]
	${10:prop}: ${11:value},
	[@bs.optional]
	${12:prop}: ${13:value},
	[@bs.optional]
	${14:prop}: ${15:value},
	[@bs.optional]
	${16:prop}: ${17:value},
	[@bs.optional]
	${18:prop}: ${19:value},
	[@bs.optional]
	${20:prop}: ${21:value},
	[@bs.optional]
	${22:prop}: ${23:value},
	[@bs.optional]
	${24:prop}: ${25:value},
	[@bs.optional]
	${26:prop}: ${27:value},
	[@bs.optional]
	${28:prop}: ${29:value},
	[@bs.optional]
	${30:prop}: ${31:value},
	[@bs.optional]
	${32:prop}: ${33:value},
	[@bs.optional]
	${34:prop}: ${35:value},
	[@bs.optional]
	${36:prop}: ${37:value},
	[@bs.optional]
	${38:prop}: ${39:value},
	[@bs.optional]
	${40:prop}: ${41:value},
	[@bs.optional]
	${42:prop}: ${43:value},
	[@bs.optional]
	${44:prop}: ${45:value},
	[@bs.optional]
	${46:prop}: ${47:value},
	[@bs.optional]
	${48:prop}: ${49:value},
	[@bs.optional]
	${50:prop}: ${51:value},
};

[@bs.module "antd/lib/$1"]
external reactClass : ReasonReact.reactClass = "default";

let make =
	(
		~$2=?,
		~$4=?,
		~$6=?,
		~$8=?,
		~$10=?,
		~$12=?,
		~$14=?,
		~$16=?,
		~$18=?,
		~$20=?,
		~$22=?,
		~$24=?,
		~$26=?,
		~$28=?,
		~$30=?,
		~$32=?,
		~$34=?,
		~$36=?,
		~$38=?,
		~$40=?,
		~$42=?,
		~$44=?,
		~$46=?,
		~$48=?,
		~$50=?,
		children,
	) =>
	ReasonReact.wrapJsForReason(
		~reactClass,
		~props=
			jsProps(
				~$2?,
				~$4?,
				~$6?,
				~$8?,
				~$10?,
				~$12?,
				~$14?,
				~$16?,
				~$18?,
				~$20?,
				~$22?,
				~$24?,
				~$26?,
				~$28?,
				~$30?,
				~$32?,
				~$34?,
				~$36?,
				~$38?,
				~$40?,
				~$42?,
				~$44?,
				~$46?,
				~$48?,
				~$50?,
				(),
			),
		children,
	);
endsnippet

snippet tsmap "type and string map"
type ${1:name} =
	| ${2:T1}
	| ${3:T2}
	| ${4:T3}
	| ${5:T4};
let string_of_$1 = t =>
	switch (t) {
	| $2 => "${6:str}"
	| $3 => "${7:str}"
	| $4 => "${8:str}"
	| $5 => "${9:str}"
	};
let $1_of_string = s =>
	switch (s) => {
	| $6 => $2
	| $7 => $3
	| $8 => $4
	| $9 => $5
	| _ => ${0:$1}
	};
endsnippet

snippet reqm "Request make"
module Request${1:Name} =
	Request.Make({
		type data = ${2:$1};
		let dataDecode = ${3:$1}Decode;
		let silent = ${4:false};
	});
endsnippet
